import React, { useState, useEffect } from 'react';
import type { Project, Provider, Prompt, Dataset, Assertion, ProjectOptions, PromptfooResults, HistoryItem } from './lib/types';
import { ProvidersForm } from './components/ProvidersForm';
import { PromptsForm } from './components/PromptsForm';
import { DatasetForm } from './components/DatasetForm';
import { AssertionsForm } from './components/AssertionsForm';
import { OptionsForm } from './components/OptionsForm';
import { YamlPreview } from './components/YamlPreview';
import { RunResults } from './components/RunResults';
import { History } from './components/History';
import { FileBar } from './components/FileBar';
import { Loader } from './components/Loader';
import { TutorialOverlay } from './components/TutorialOverlay';
import { Documentation } from './components/Documentation';
import { buildPromptfooYaml, buildSecurityTestYaml, validateDatasetVariables } from './lib/buildYaml';
import { ProjectNameSchema } from './lib/schemas';
import { useToast } from './contexts/ToastContext';
import { useTutorial } from './contexts/TutorialContext';

type Tab = 'providers' | 'prompts' | 'dataset' | 'assertions' | 'settings' | 'results' | 'history';

function App() {
  const toast = useToast();
  const tutorial = useTutorial();
  const [isLoading, setIsLoading] = useState(true);
  const [userDataPath, setUserDataPath] = useState<string>('');
  const [activeTab, setActiveTab] = useState<Tab>('prompts');
  const [projectName, setProjectName] = useState('My First Project');
  const [projectNameError, setProjectNameError] = useState<string | null>(null);
  const [hasProviderErrors, setHasProviderErrors] = useState(false);
  const [shouldValidateProviders, setShouldValidateProviders] = useState(false);
  const [hasPromptErrors, setHasPromptErrors] = useState(false);
  const [shouldValidatePrompts, setShouldValidatePrompts] = useState(false);
  const [pendingTab, setPendingTab] = useState<Tab | null>(null);
  const [activeYamlView, setActiveYamlView] = useState<'main' | 'security'>('main');
  const [isBigQuerySyncing, setIsBigQuerySyncing] = useState(false);

  // Debug: Log when BigQuery sync state changes
  useEffect(() => {
    console.log('isBigQuerySyncing changed to:', isBigQuerySyncing);
  }, [isBigQuerySyncing]);

  const [providers, setProviders] = useState<Provider[]>([
    {
      id: 'provider-1',
      providerId: 'google:gemini-2.5-flash',
      config: {},
    },
  ]);

  // Sync tutorial active tab with app active tab
  useEffect(() => {
    const stepConfig = tutorial.getCurrentStepConfig();
    if (tutorial.isActive && stepConfig?.targetTab && stepConfig.targetTab !== activeTab) {
      setActiveTab(stepConfig.targetTab);
    }
  }, [tutorial.isActive, tutorial.currentStep]);

  // Handle tab change with validation
  const handleTabChange = async (tab: Tab) => {
    // Block navigation if BigQuery is syncing
    if (isBigQuerySyncing) {
      toast.warning('Please wait for BigQuery sync to complete before navigating.');
      return;
    }

    // Validate BigQuery configuration when leaving settings tab
    if (activeTab === 'settings' && tab !== 'settings') {
      const bqEnabled = (options as any)?.bigQueryEnabled === true;
      const bqProjectId = ((options as any)?.bigQueryProjectId || '').trim();
      const bqDatasetId = ((options as any)?.bigQueryDatasetId || '').trim();
      const bqTableId = ((options as any)?.bigQueryTableId || '').trim();

      // Validate BigQuery Reference configuration when leaving settings tab
      const bqRefEnabled = (options as any)?.bigQueryReferenceEnabled === true;
      const bqRefProjectId = ((options as any)?.bigQueryReferenceProjectId || '').trim();
      const bqRefDatasetId = ((options as any)?.bigQueryReferenceDatasetId || '').trim();
      const bqRefTableId = ((options as any)?.bigQueryReferenceTableId || '').trim();

      const updates: any = {};

      if (bqEnabled && (!bqProjectId || !bqDatasetId || !bqTableId)) {
        // Auto-disable BigQuery if fields are missing
        updates.bigQueryEnabled = false;
        toast.warning('BigQuery integration has been disabled because the required table details were not provided.');
      }

      if (bqRefEnabled && (!bqRefProjectId || !bqRefDatasetId || !bqRefTableId)) {
        // Auto-disable BigQuery Reference if fields are missing
        updates.bigQueryReferenceEnabled = false;
        toast.warning('BigQuery Reference has been disabled because the required table details were not provided.');
      }

      if (Object.keys(updates).length > 0) {
        setOptions({
          ...options,
          ...updates,
        } as any);
      }
    }

    if (activeTab === 'providers' && tab !== 'providers') {
      // Trigger validation when trying to leave providers tab
      setShouldValidateProviders(true);
      setPendingTab(tab);
    } else if (activeTab === 'prompts' && tab !== 'prompts') {
      // Trigger validation when trying to leave prompts tab
      setShouldValidatePrompts(true);
      setPendingTab(tab);
    } else if (activeTab === 'dataset' && tab !== 'dataset' && hasUnsavedDatasetData) {
      // Warn about unsaved data when trying to leave dataset tab
      toast.warning('You have unsaved data in the paste area. It will be auto-saved now.');
      // Data will be auto-saved by the onBlur handler
      setActiveTab(tab);
      setPendingTab(null);
    } else {
      // Allow navigation if not leaving providers/prompts/dataset tab
      setActiveTab(tab);
      setPendingTab(null);

      // Auto-load results when navigating to results tab
      if (tab === 'results' && !results && options.jsonOutputPath) {
        try {
          if (window.api?.readJsonResults) {
            const result = await window.api.readJsonResults(options.jsonOutputPath);
            if (result.success && result.results) {
              setResults(result.results);
            }
          }
        } catch (error) {
          console.error('Failed to auto-load results:', error);
        }
      }
    }
  };

  // Check validation after it's triggered and navigate or block
  React.useEffect(() => {
    if (pendingTab && shouldValidateProviders) {
      // Small delay to ensure validation has completed
      const timer = setTimeout(() => {
        if (hasProviderErrors) {
          const message = providers.length === 0
            ? 'Please add at least one provider before leaving this tab.'
            : 'Please fix all provider validation errors before leaving this tab.';
          toast.warning(message);
          setPendingTab(null);
        } else {
          setActiveTab(pendingTab);
          setPendingTab(null);
        }
      }, 100);
      return () => clearTimeout(timer);
    }
  }, [pendingTab, shouldValidateProviders, hasProviderErrors, providers.length]);

  // Check prompt validation
  React.useEffect(() => {
    if (pendingTab && shouldValidatePrompts) {
      // Small delay to ensure validation has completed
      const timer = setTimeout(() => {
        if (hasPromptErrors) {
          toast.warning('Please fix all prompt validation errors before leaving this tab.');
          setPendingTab(null);
        } else {
          setActiveTab(pendingTab);
          setPendingTab(null);
        }
      }, 100);
      return () => clearTimeout(timer);
    }
  }, [pendingTab, shouldValidatePrompts, hasPromptErrors]);

  const [prompts, setPrompts] = useState<Prompt[]>([
    {
      id: 'prompt-1',
      label: 'Sample Prompt',
      text: 'You are a helpful assistant. Please answer the following question: {{question}}\n\nReturn the answer in JSON format.\n\nExample:\n{"answer": "Answer from model here"}',
    },
  ]);

  const [dataset, setDataset] = useState<Dataset | undefined>(undefined);
  const [assertions, setAssertions] = useState<Assertion[]>([]);
  const [options, setOptions] = useState<ProjectOptions>({
    outputPath: '~/Library/Application Support/promptfooplusplus/output.html',
    jsonOutputPath: '~/Library/Application Support/promptfooplusplus/output.json',
    maxConcurrency: 4,
    cache: false,
    openReportAfterTest: false,
  });

  const [isRunning, setIsRunning] = useState(false);
  const [results, setResults] = useState<PromptfooResults | null>(null);
  const [securityResults, setSecurityResults] = useState<PromptfooResults | null>(null);
  const [aiAnalysis, setAiAnalysis] = useState<any>(null); // Persist AI analysis results
  const [logs, setLogs] = useState<string[]>([]);
  const [showLogs, setShowLogs] = useState(false);
  const [promptfooInstalled, setPromptfooInstalled] = useState<boolean | null>(null);
  const [progress, setProgress] = useState({ current: 0, total: 0 });
  const [currentRunId, setCurrentRunId] = useState<string | null>(null);
  const [hasUnsavedDatasetData, setHasUnsavedDatasetData] = useState(false);
  const [showYamlPreview, setShowYamlPreview] = useState(false);
  const [suggestedPrompts, setSuggestedPrompts] = useState<Prompt[] | null>(null);
  const [showRerunConfirmation, setShowRerunConfirmation] = useState(false);
  const [showSettingsModal, setShowSettingsModal] = useState(false);

  const handleCloseSettingsModal = () => {
    // Validate BigQuery configuration before closing modal
    const bqEnabled = (options as any)?.bigQueryEnabled === true;
    const bqProjectId = ((options as any)?.bigQueryProjectId || '').trim();
    const bqDatasetId = ((options as any)?.bigQueryDatasetId || '').trim();
    const bqTableId = ((options as any)?.bigQueryTableId || '').trim();

    // Validate BigQuery Reference configuration before closing modal
    const bqRefEnabled = (options as any)?.bigQueryReferenceEnabled === true;
    const bqRefProjectId = ((options as any)?.bigQueryReferenceProjectId || '').trim();
    const bqRefDatasetId = ((options as any)?.bigQueryReferenceDatasetId || '').trim();
    const bqRefTableId = ((options as any)?.bigQueryReferenceTableId || '').trim();

    const updates: any = {};

    if (bqEnabled && (!bqProjectId || !bqDatasetId || !bqTableId)) {
      // Auto-disable BigQuery if fields are missing
      updates.bigQueryEnabled = false;
      toast.warning('BigQuery integration has been disabled because the required table details were not provided.');
    }

    if (bqRefEnabled && (!bqRefProjectId || !bqRefDatasetId || !bqRefTableId)) {
      // Auto-disable BigQuery Reference if fields are missing
      updates.bigQueryReferenceEnabled = false;
      toast.warning('BigQuery Reference has been disabled because the required table details were not provided.');
    }

    if (Object.keys(updates).length > 0) {
      setOptions({
        ...options,
        ...updates,
      } as any);
    }

    setShowSettingsModal(false);
  };
  const [showDocumentation, setShowDocumentation] = useState(false);
  const [missingExpectedOutputError, setMissingExpectedOutputError] = useState<string | null>(null);

  // Track last evaluated project to prevent showing stale results
  const [lastEvaluatedProject, setLastEvaluatedProject] = useState<string | null>(null);

  // Initialize app and check if promptfoo is installed
  useEffect(() => {
    const initializeApp = async () => {
      try {
        // Simulate minimum loading time for better UX
        const minLoadTime = new Promise(resolve => setTimeout(resolve, 1000));

        // Check if we're running in Electron or browser with timeout
        if (window.api?.checkPromptfooInstalled) {
          // Get user data path
          const dataPath = await window.api.getUserDataPath();
          setUserDataPath(dataPath);

          const checkPromise = window.api.checkPromptfooInstalled();
          const timeoutPromise = new Promise<boolean>((resolve) =>
            setTimeout(() => resolve(false), 5000) // 5 second timeout
          );

          const installed = await Promise.race([checkPromise, timeoutPromise]);
          setPromptfooInstalled(installed);

          // Check BigQuery API token on startup
          if (window.api?.testBigQueryConnection) {
            try {
              const bqResult = await window.api.testBigQueryConnection({
                projectId: options.bigQueryProjectId,
                datasetId: options.bigQueryDatasetId,
                tableId: options.bigQueryTableId,
              });

              if (!bqResult.success && bqResult.hasApiKey === false) {
                console.warn('BQ_API_TOKEN not configured. BigQuery export will be disabled.');
                toast.warning('BigQuery: BQ_API_TOKEN not found. Add to .env file to enable auto-export.', 8000);
              } else if (bqResult.success) {
                console.log('BigQuery connection verified successfully');
              }
            } catch (error) {
              console.error('Failed to check BigQuery connection:', error);
            }
          }
        } else {
          // Running in browser mode - skip promptfoo check
          setPromptfooInstalled(null);
        }

        // Wait for minimum load time
        await minLoadTime;
      } catch (error) {
        console.error('Error during initialization:', error);
      } finally {
        // Always hide loader, even if there's an error
        setIsLoading(false);
      }
    };

    initializeApp();
  }, []);

  // Update output paths when userDataPath is available
  useEffect(() => {
    if (userDataPath && options.outputPath.includes('~/Library')) {
      setOptions(prev => ({
        ...prev,
        outputPath: `${userDataPath}/output.html`,
        jsonOutputPath: `${userDataPath}/output.json`,
      }));
    }
  }, [userDataPath]);

  // Clear results when project configuration changes (but not on first load)
  // Note: options are excluded from the hash as they don't affect test results
  // Note: results is NOT in the dependency array to avoid circular updates
  useEffect(() => {
    // Create a hash of current project configuration
    const currentProjectHash = JSON.stringify({
      name: projectName,
      providers: providers.map(p => ({ id: p.providerId, config: p.config })),
      prompts: prompts.map(p => ({ id: p.id, text: p.text })),
      dataset: dataset,
      assertions: assertions.map(a => ({ type: a.type, value: a.value })),
    });

    // If we have results but the project has changed, clear them
    if (results && lastEvaluatedProject && lastEvaluatedProject !== currentProjectHash) {
      console.log('Project configuration changed, clearing stale results');
      setResults(null);
    }
  }, [projectName, providers, prompts, dataset, assertions, lastEvaluatedProject]);

  const project: Project = {
    name: projectName,
    providers,
    prompts,
    dataset,
    assertions,
    options,
  };

  // Helper function to save results to history
  const saveResultsToHistory = async (evaluationResults: PromptfooResults) => {
    try {
      if (!window.api?.saveToHistory) {
        console.log('History API not available');
        return;
      }

      // Calculate stats from results
      // Results are in evaluationResults.results.results array
      const testResults = evaluationResults?.results?.results || [];
      let totalTests = 0;
      let passed = 0;
      let totalScore = 0;
      let totalLatency = 0;
      let totalCost = 0;

      testResults.forEach((testResult: any) => {
        totalTests++;
        if (testResult.success || testResult.gradingResult?.pass) {
          passed++;
        }
        totalScore += testResult.score || 0;
        totalLatency += testResult.latencyMs || 0;
        totalCost += testResult.cost || 0;
      });

      const historyItem: HistoryItem = {
        id: `eval-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        projectName: projectName,
        timestamp: new Date().toISOString(),
        results: evaluationResults,
        project: {
          name: projectName,
          providers,
          prompts,
          dataset,
          assertions,
          options,
        },
        stats: {
          totalTests,
          passed,
          failed: totalTests - passed,
          avgScore: totalTests > 0 ? totalScore / totalTests : 0,
          totalCost,
          totalLatency,
        },
      };

      console.log('Saving to history:', {
        projectName,
        totalTests,
        passed,
        avgScore: historyItem.stats.avgScore,
      });

      const saveResult = await window.api.saveToHistory(historyItem);
      if (saveResult.success) {
        console.log('Saved evaluation to history:', projectName);

        // Auto-export to BigQuery if enabled
        // Default to disabled (false) if undefined - users must explicitly enable
        const bigQueryEnabled = (options as any)?.bigQueryEnabled === true;
        console.log('[BigQuery] Checking export conditions...');
        console.log('[BigQuery] bigQueryEnabled:', (options as any)?.bigQueryEnabled, '(normalized:', bigQueryEnabled, ')');
        console.log('[BigQuery] exportToBigQuery API available:', !!window.api?.exportToBigQuery);

        if (bigQueryEnabled && window.api?.exportToBigQuery) {
          console.log('[BigQuery] Starting auto-export...');
          try {
            const bqConfig = {
              projectId: (options as any).bigQueryProjectId,
              datasetId: (options as any).bigQueryDatasetId,
              tableId: (options as any).bigQueryTableId,
            };
            console.log('[BigQuery] Config:', bqConfig);
            console.log('[BigQuery] Project name:', projectName);
            console.log('[BigQuery] Evaluation ID:', historyItem.id);
            console.log('[BigQuery] Results structure:', {
              hasResults: !!evaluationResults,
              hasResultsResults: !!(evaluationResults as any)?.results,
              resultsLength: (evaluationResults as any)?.results?.results?.length || 0
            });

            const exportResult = await window.api.exportToBigQuery({
              config: bqConfig,
              results: evaluationResults,
              projectName: projectName,
              evaluationId: historyItem.id,
            });

            console.log('[BigQuery] Export result:', exportResult);

            if (exportResult.success) {
              console.log(`[BigQuery] Successfully exported ${exportResult.insertedRows} rows to BigQuery`);
              toast.success(`Exported ${exportResult.insertedRows} rows to BigQuery!`);
            } else {
              console.error('[BigQuery] Export failed:', exportResult.error);
              toast.error(`BigQuery export failed: ${exportResult.error}`);
            }
          } catch (error: any) {
            console.error('[BigQuery] Export error:', error);
            toast.error(`BigQuery export failed: ${error.message}`);
          }
        } else {
          console.log('[BigQuery] Export skipped - not enabled or API not available');
        }
      } else {
        console.error('Failed to save to history:', saveResult.error);
      }
    } catch (error: any) {
      console.error('Error saving to history:', error);
      // Don't fail the evaluation if history save fails
    }
  };

  const handleRunEval = async () => {
    try {
      // Validate project name
      if (projectNameError) {
        toast.error(`Invalid project name: ${projectNameError}`);
        return;
      }

      // Validate project
      if (providers.length === 0) {
        toast.warning('Please add at least one provider');
        setActiveTab('providers');
        return;
      }

      // Validate all providers have valid IDs
      const invalidProviders = providers.filter(p => !p.providerId || !p.providerId.includes(':'));
      if (invalidProviders.length > 0) {
        toast.warning('Some providers have invalid or missing provider IDs. Please check the Providers tab.');
        setActiveTab('providers');
        return;
      }

      if (prompts.length === 0) {
        toast.warning('Please add at least one prompt');
        setActiveTab('prompts');
        return;
      }

      // Check if prompts have variables
      const allVariables = new Set<string>();
      prompts.forEach((prompt) => {
        const vars = prompt.text.match(/\{\{(\w+)\}\}/g);
        if (vars) {
          vars.forEach((v) => {
            const varName = v.replace(/\{\{|\}\}/g, '');
            allVariables.add(varName);
          });
        }
      });

      // Check if security testing is enabled (check early)
      const hasSecurityTests = options?.enableSecurityTests &&
                               prompts.length > 0 &&
                               allVariables.size > 0;

      // Determine if we need to run functional tests
      const needsFunctionalTests = assertions && assertions.length > 0;

      // If prompts have variables, validate dataset (only required for functional tests)
      // Security tests generate their own test data, so dataset is optional when running only security tests
      if (allVariables.size > 0 && needsFunctionalTests) {
        // Check if dataset exists and has rows
        if (!dataset || !dataset.rows || dataset.rows.length === 0) {
          toast.error(
            `Your prompts use variables (${Array.from(allVariables).join(', ')}), but no dataset is provided. Please add a dataset in the Dataset tab.`
          );
          setActiveTab('dataset');
          return;
        }

        // Validate that dataset has all required variables
        const validation = validateDatasetVariables(prompts, dataset.rows);
        if (!validation.valid) {
          toast.error(
            `Dataset is missing required variables: ${validation.missing.join(', ')}. Please add these columns to your dataset.`
          );
          setActiveTab('dataset');
          return;
        }
      }

      // Validate assertions - only required if security tests are NOT enabled
      // If security tests are enabled, they act as assertions automatically
      if ((!assertions || assertions.length === 0) && !hasSecurityTests) {
        toast.error(
          'Please add at least one assertion to validate your test results. Go to the Assertions tab to add assertions, or enable Security Testing in Options.'
        );
        setActiveTab('assertions');
        return;
      }

      // Check if any assertions require expected_output column
      const assertionsRequiringExpectedOutput = ['factuality', 'similar'];
      const hasAssertionRequiringExpectedOutput = assertions?.some(a =>
        assertionsRequiringExpectedOutput.includes(a.type) &&
        a.value &&
        typeof a.value === 'string' &&
        a.value.includes('{{expected_output}}')
      );

      if (hasAssertionRequiringExpectedOutput) {
        // Check if dataset has expected_output or similar column
        const datasetHeaders = dataset?.rows && dataset.rows.length > 0
          ? Object.keys(dataset.rows[0])
          : [];

        const hasExpectedColumn = datasetHeaders.some(h =>
          h.toLowerCase().startsWith('expected')
        );

        if (!hasExpectedColumn) {
          // Get list of assertions that require expected_output
          const assertionTypesNeedingIt = assertions
            ?.filter(a =>
              assertionsRequiringExpectedOutput.includes(a.type) &&
              a.value &&
              typeof a.value === 'string' &&
              a.value.includes('{{expected_output}}')
            )
            .map(a => a.type)
            .join(', ') || 'assertions';

          const errorMessage = `Missing required "expected_output" column for: ${assertionTypesNeedingIt}`;
          setMissingExpectedOutputError(errorMessage);

          toast.error(
            'Your assertions use {{expected_output}} but your dataset does not have an "expected_output" or "expected_*" column. Please add this column to your dataset.',
            { duration: 6000 }
          );
          setActiveTab('dataset');
          return;
        }
      }

      // Clear the error if validation passes
      setMissingExpectedOutputError(null);

      // Validate BigQuery configuration if explicitly enabled
      const bigQueryEnabled = (options as any)?.bigQueryEnabled === true;
      console.log('[BigQuery Validation] Enabled:', bigQueryEnabled);

      if (bigQueryEnabled) {
        const bqProjectId = ((options as any)?.bigQueryProjectId || '').trim();
        const bqDatasetId = ((options as any)?.bigQueryDatasetId || '').trim();
        const bqTableId = ((options as any)?.bigQueryTableId || '').trim();

        console.log('[BigQuery Validation] ProjectId:', bqProjectId);
        console.log('[BigQuery Validation] DatasetId:', bqDatasetId);
        console.log('[BigQuery Validation] TableId:', bqTableId);

        if (!bqProjectId || !bqDatasetId || !bqTableId) {
          console.log('[BigQuery Validation] FAILED - Missing credentials');
          toast.error(
            'Store evaluation results in Google BigQuery is turned on but the table details are not configured. Please configure BigQuery settings in the Options tab or disable BigQuery integration.',
            { duration: 8000 }
          );
          setActiveTab('options');
          return;
        }
        console.log('[BigQuery Validation] PASSED');
      }

      // Calculate total tests for progress tracking
      const totalTests = (dataset?.rows.length || 0) * providers.length * prompts.length;

      setIsRunning(true);
      setLogs([]);
      setShowLogs(true);
      setResults(null);
      setSecurityResults(null); // Also clear security results
      setAiAnalysis(null); // Clear AI analysis for new run
      setProgress({ current: 0, total: totalTests });

      // Generate a unique run ID
      const runId = Date.now().toString();
      setCurrentRunId(runId);

      const yamlContent = buildPromptfooYaml(project);

      if (!window.api?.runPromptfoo) {
        toast.error('This feature requires running the app in Electron mode. Please use "npm run dev" to start the full app.');
        return;
      }

      // Determine if we should run functional tests
      const shouldRunFunctionalTests = assertions && assertions.length > 0;

      // Run main functional tests (only if there are assertions)
      let result = null;
      let evaluationResults = null;

      if (shouldRunFunctionalTests) {
        result = await window.api.runPromptfoo(yamlContent, runId, (log, progressUpdate) => {
          setLogs((prev) => [...prev, `[Functional] ${log}`]);
          if (progressUpdate) {
            setProgress({ current: progressUpdate.current, total: progressUpdate.total });
          }
        });

        console.log('Evaluation result:', result);
        console.log('Result success:', result.success);
        console.log('Result.results:', result.results);

        // Try to load results from file even if evaluation failed
        evaluationResults = result.results;
        if (!evaluationResults && !result.aborted && options.jsonOutputPath) {
          console.log('ðŸ”µ No results in response, trying to load from file...');
          try {
            if (window.api?.readJsonResults) {
              const fileResult = await window.api.readJsonResults(options.jsonOutputPath);
              if (fileResult.success && fileResult.results) {
                evaluationResults = fileResult.results;
                console.log('ðŸ”µ Successfully loaded results from file');
              }
            }
          } catch (error) {
            console.error('Failed to load results from file:', error);
          }
        }

        // Save to history if we have results, regardless of success/failure
        if (evaluationResults) {
          console.log('ðŸ”µ About to save to history...');
          await saveResultsToHistory(evaluationResults);
          console.log('ðŸ”µ Finished saving to history');
        }
      } else {
        console.log('â„¹ï¸ Skipping functional tests - no assertions defined. Running security tests only.');
        setLogs((prev) => [...prev, 'â„¹ï¸ No functional assertions defined - running security tests only']);
      }

      // Run security tests if enabled
      let securityResult = null;
      if (hasSecurityTests) {
        setLogs((prev) => [...prev, '\n=== Starting Security Tests ===\n']);
        const securityYamlContent = buildSecurityTestYaml(project);
        const securityRunId = `${runId}-security`;

        console.log('ðŸ”’ Running security tests with runId:', securityRunId);
        securityResult = await window.api.runPromptfoo(securityYamlContent, securityRunId, (log, progressUpdate) => {
          setLogs((prev) => [...prev, `[Security] ${log}`]);
          if (progressUpdate) {
            // Don't update main progress bar for security tests
            setLogs((prev) => [...prev, `[Security] Progress: ${progressUpdate.current}/${progressUpdate.total}`]);
          }
        });
        console.log('ðŸ”’ Security test result:', securityResult);
        console.log('ðŸ”’ Security result success:', securityResult?.success);
        console.log('ðŸ”’ Security result.results:', securityResult?.results);
      }

      // Handle security results
      console.log('ðŸ”’ Handling security results...');
      console.log('ðŸ”’ securityResult exists:', !!securityResult);
      console.log('ðŸ”’ securityResult.success:', securityResult?.success);
      console.log('ðŸ”’ securityResult.results:', securityResult?.results);

      if (securityResult && securityResult.success && securityResult.results) {
        console.log('ðŸ”’ Setting security results to state:', securityResult.results);
        setSecurityResults(securityResult.results);
      } else if (securityResult && options?.jsonOutputPath) {
        // Try to load security results from file
        // Auto-generate security path from main output path
        const securityJsonPath = options.jsonOutputPath.replace(/\.json$/, '-security.json');
        console.log('ðŸ”’ Trying to load security results from:', securityJsonPath);
        try {
          if (window.api?.readJsonResults) {
            const fileResult = await window.api.readJsonResults(securityJsonPath);
            if (fileResult.success && fileResult.results) {
              setSecurityResults(fileResult.results);
              console.log('ðŸ”’ Successfully loaded security results from file');
            }
          }
        } catch (error) {
          console.error('Failed to load security results from file:', error);
        }
      }

      // Handle success cases based on what tests ran
      const functionalTestsSucceeded = result && result.success && result.results;
      const securityTestsSucceeded = securityResult && securityResult.success && securityResult.results;

      if (functionalTestsSucceeded) {
        console.log('Setting results to state:', result.results);
        setResults(result.results);
      }

      // Show success if either functional or security tests succeeded
      if (functionalTestsSucceeded || securityTestsSucceeded) {
        setShowLogs(false);

        // Save project hash to detect future changes
        const currentProjectHash = JSON.stringify({
          name: projectName,
          providers: providers.map(p => ({ id: p.providerId, config: p.config })),
          prompts: prompts.map(p => ({ id: p.id, text: p.text })),
          dataset: dataset,
          assertions: assertions.map(a => ({ type: a.type, value: a.value })),
        });
        setLastEvaluatedProject(currentProjectHash);

        // Automatically switch to Results tab
        setActiveTab('results');
        console.log('Switched to results tab');

        // Determine success message based on what ran
        let successMsg = '';
        if (functionalTestsSucceeded && securityTestsSucceeded) {
          successMsg = 'Functional and Security evaluations completed';
        } else if (securityTestsSucceeded) {
          successMsg = 'Security evaluation completed';
        } else {
          successMsg = 'Evaluation completed';
        }
        toast.success(successMsg);

        // Open HTML report if option is enabled and result exists
        if (options.openReportAfterTest && options.outputPath && result?.htmlPath) {
          try {
            if (window.api?.openPath) {
              const openResult = await window.api.openPath(result.htmlPath);
              if (!openResult.success) {
                console.error('Failed to open HTML report:', openResult.error);
              }
            }
          } catch (error: any) {
            console.error('Failed to open HTML report:', error);
            // Don't show a toast - the evaluation succeeded, just opening failed
          }
        }
      } else if (result?.aborted) {
        toast.warning('Evaluation was aborted');
        setLogs(result.logs || []);
      } else if (result) {
        // Even if evaluation failed (e.g., exit code 100), show completed message
        toast.success('Evaluation completed');
        if (result.logs) {
          setLogs(result.logs);
        }
      }
    } catch (error: any) {
      toast.error(`Failed to run evaluation: ${error.message}`);
    } finally {
      setIsRunning(false);
      setCurrentRunId(null);
      setProgress({ current: 0, total: 0 });
    }
  };

  const handleAbortEval = async () => {
    if (currentRunId && window.api?.abortPromptfoo) {
      try {
        await window.api.abortPromptfoo(currentRunId);
        toast.warning('Aborting evaluation...');
      } catch (error: any) {
        console.error('Failed to abort evaluation:', error);
        toast.error(`Failed to abort: ${error.message}`);
      }
    }
  };

  const handleProjectNameChange = (value: string) => {
    setProjectName(value);

    // Validate project name
    const result = ProjectNameSchema.safeParse(value);
    if (!result.success) {
      setProjectNameError(result.error.errors[0].message);
    } else {
      setProjectNameError(null);
    }
  };

  const handleLoadProject = (loadedProject: Project) => {
    setProjectName(loadedProject.name);
    setProjectNameError(null);
    setProviders(loadedProject.providers);
    setPrompts(loadedProject.prompts);
    setDataset(loadedProject.dataset);
    setAssertions(loadedProject.assertions);
    setOptions(loadedProject.options || {});
  };

  const handleApplySuggestions = (suggestions: string[]) => {
    // Parse suggestions and create suggested prompts
    // All suggestions will be appended at the end of the prompt

    if (!suggestions || suggestions.length === 0) {
      toast.warning('No suggestions found to apply');
      return;
    }

    // Create suggested prompts by appending all suggestions at the end
    const newSuggestedPrompts = prompts.map((prompt) => {
      // Start with the original prompt text
      let updatedText = prompt.text.trim();

      // Add a separator and append all suggestions
      updatedText += '\n\n---\n\n';
      updatedText += '## AI-SUGGESTED IMPROVEMENTS:\n\n';

      // Add each suggestion as a numbered item
      suggestions.forEach((suggestion, index) => {
        // Use the full suggestion text, no extraction
        updatedText += `${index + 1}. ${suggestion}\n\n`;
      });

      return {
        ...prompt,
        text: updatedText.trim(),
      };
    });

    setSuggestedPrompts(newSuggestedPrompts);
    setActiveTab('prompts'); // Switch to prompts tab to show the diff
    toast.info('Review suggested prompt changes in the Prompts tab');
  };

  const handleAcceptSuggestions = () => {
    if (!suggestedPrompts) return;

    setPrompts(suggestedPrompts);
    setSuggestedPrompts(null);
    setShowRerunConfirmation(true);
  };

  const handleRejectSuggestions = () => {
    setSuggestedPrompts(null);
    toast.info('Prompt suggestions discarded');
  };

  const handleConfirmRerun = () => {
    setShowRerunConfirmation(false);
    handleRunEval();
  };

  const handleCancelRerun = () => {
    setShowRerunConfirmation(false);
    toast.info('You can manually run the evaluation when ready');
  };

  const tabs: Array<{ id: Tab; label: string; badge?: number }> = [
    { id: 'prompts', label: 'Prompts', badge: prompts.length },
    { id: 'providers', label: 'Providers', badge: providers.length },
    { id: 'dataset', label: 'Dataset', badge: dataset?.rows.length },
    { id: 'assertions', label: 'Assertions', badge: assertions.length },
    { id: 'results', label: 'Results' },
    { id: 'history', label: 'History' },
  ];

  // Show loader while initializing
  if (isLoading) {
    return <Loader />;
  }

  return (
    <div className="h-screen flex flex-col bg-white">
      <TutorialOverlay />

      <FileBar
        project={project}
        onLoadProject={handleLoadProject}
        onRunEval={handleRunEval}
        isRunning={isRunning}
        hasValidationErrors={hasProviderErrors || hasPromptErrors || !!projectNameError}
        onValidateProviders={() => setShouldValidateProviders(true)}
        onValidatePrompts={() => setShouldValidatePrompts(true)}
        onPreviewYaml={() => setShowYamlPreview(true)}
        activeYamlView={activeYamlView}
        onYamlViewChange={setActiveYamlView}
        onOpenSettings={() => setShowSettingsModal(true)}
        onOpenDocumentation={() => setShowDocumentation(true)}
      />

      {/* Promptfoo CLI check removed - GUI app has built-in evaluation functionality */}

      <div className="flex-1 flex overflow-hidden">
        {/* Left sidebar - tabs */}
        <div className="w-64 border-r bg-gray-50 flex flex-col">
          <div className="p-4 border-b">
            <label className="block text-xs font-medium text-muted-foreground mb-1">
              Project Name
            </label>
            <input
              type="text"
              value={projectName}
              onChange={(e) => handleProjectNameChange(e.target.value)}
              maxLength={100}
              className={`w-full px-3 py-2 border rounded-md text-sm ${
                projectNameError ? 'border-red-500 focus:ring-red-500' : ''
              }`}
              placeholder="e.g., My Evaluation"
            />
            {projectNameError && (
              <p className="mt-1 text-xs text-red-600">{projectNameError}</p>
            )}
            <p className="mt-1 text-xs text-muted-foreground">
              {projectName.length}/100 characters
              {projectName.length >= 100 && <span className="text-orange-600 ml-1">(Maximum reached)</span>}
            </p>
          </div>

          <nav className="flex-1 p-2 space-y-1">
            {tabs.map((tab) => {
              const isDisabledByProviders = activeTab === 'providers' && tab.id !== 'providers' && hasProviderErrors;
              const isDisabledByPrompts = activeTab === 'prompts' && tab.id !== 'prompts' && hasPromptErrors;
              const isDisabled = isDisabledByProviders || isDisabledByPrompts;

              const tooltipMessage = isDisabledByProviders
                ? 'Fix provider validation errors to enable navigation'
                : isDisabledByPrompts
                ? 'Fix prompt validation errors to enable navigation'
                : '';

              return (
                <button
                  key={tab.id}
                  onClick={() => handleTabChange(tab.id)}
                  disabled={isDisabled}
                  className={`w-full text-left px-3 py-2 rounded-md text-sm font-medium transition-colors ${
                    activeTab === tab.id
                      ? 'bg-blue-600 text-white'
                      : isDisabled
                      ? 'text-gray-400 cursor-not-allowed opacity-60'
                      : 'text-gray-700 hover:bg-gray-200'
                  }`}
                  title={tooltipMessage}
                >
                <span>{tab.label}</span>
                {tab.badge !== undefined && (
                  <span
                    className={`ml-2 px-2 py-0.5 rounded-full text-xs ${
                      activeTab === tab.id
                        ? 'bg-blue-500 text-white'
                        : 'bg-gray-300 text-gray-700'
                    }`}
                  >
                    {tab.badge}
                  </span>
                )}
              </button>
              );
            })}
          </nav>
        </div>

        {/* Main content area */}
        <div className="flex-1 overflow-auto p-6 flex flex-col">
          <div className="flex-1">
            {activeTab === 'providers' && (
              <div className="providers-form">
                <ProvidersForm
                  providers={providers}
                  onChange={setProviders}
                  onValidationChange={setHasProviderErrors}
                  shouldValidate={shouldValidateProviders}
                />
              </div>
            )}

            {activeTab === 'prompts' && (
              <div className="prompts-form">
                <PromptsForm
                  prompts={prompts}
                  onChange={setPrompts}
                  onValidationChange={setHasPromptErrors}
                  shouldValidate={shouldValidatePrompts}
                  suggestedPrompts={suggestedPrompts}
                  onAcceptSuggestions={handleAcceptSuggestions}
                  onRejectSuggestions={handleRejectSuggestions}
                />
              </div>
            )}

            {activeTab === 'dataset' && (
              <div className="dataset-form">
                <DatasetForm
                  dataset={dataset}
                  onChange={setDataset}
                  prompts={prompts}
                  options={options}
                  onUnsavedDataChange={setHasUnsavedDatasetData}
                  validationError={missingExpectedOutputError}
                />
              </div>
            )}

            {activeTab === 'assertions' && (
              <div className="assertions-form">
                <AssertionsForm assertions={assertions} onChange={setAssertions} providers={providers} prompts={prompts} dataset={dataset} onDatasetChange={setDataset} options={options} />
              </div>
            )}

            {activeTab === 'settings' && (
              <div className="settings-form">
                <OptionsForm
                  options={options}
                  onChange={setOptions}
                  onBigQuerySyncChange={(syncing) => {
                    console.log('App.tsx: onBigQuerySyncChange called with:', syncing);
                    setIsBigQuerySyncing(syncing);
                  }}
                />
              </div>
            )}

            {activeTab === 'results' && (
              <div className="h-full results-view">
                {results ? (
                  <div className="relative h-full">
                    <RunResults
                      results={results}
                      securityResults={securityResults}
                      aiAnalysis={aiAnalysis}
                      onAiAnalysisChange={setAiAnalysis}
                      onApplySuggestions={handleApplySuggestions}
                      projectOptions={options}
                      onClose={() => {
                        setResults(null);
                        setSecurityResults(null);
                      }}
                      onRefresh={(newResults) => setResults(newResults)}
                    />
                  </div>
                ) : (
                  <div className="flex items-center justify-center h-full">
                    <div className="text-center">
                      <div className="text-6xl mb-4">ðŸ“Š</div>
                      <h3 className="text-xl font-semibold text-gray-700 mb-2">Test Results Cleared</h3>
                      <p className="text-gray-600 mb-4">
                        Test results are cleared. Refresh the page to see the last test report.
                      </p>
                      <div className="flex gap-3 justify-center">
                        <button
                          onClick={async () => {
                            if (!window.api?.readJsonResults || !options.jsonOutputPath) {
                              return;
                            }
                            try {
                              const result = await window.api.readJsonResults(options.jsonOutputPath);
                              if (result.success && result.results) {
                                setResults(result.results);
                              }
                            } catch (error) {
                              console.error('Failed to refresh results:', error);
                            }
                          }}
                          className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 flex items-center gap-2"
                        >
                          <svg className="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                          </svg>
                          Refresh
                        </button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            )}

            {activeTab === 'history' && (
              <div className="h-full">
                <History projectOptions={options} />
              </div>
            )}
          </div>

          {/* Footer */}
          <div className="mt-6 pt-4 border-t text-center text-xs text-muted-foreground">
            Copyright syamsasi
          </div>
        </div>
      </div>

      {/* YAML Preview Modal */}
      {showYamlPreview && (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-2xl shadow-2xl w-[90vw] max-w-7xl h-[90vh] flex flex-col overflow-hidden border border-gray-200">
            <div className="bg-gradient-to-r from-green-600 via-emerald-600 to-teal-600 text-white p-4">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <div className="bg-white/20 p-2 rounded-lg">
                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                  </div>
                  <div>
                    <h2 className="text-xl font-bold">YAML Configuration Preview</h2>
                    <p className="text-xs text-white/80 mt-0.5">
                      Preview your Promptfoo configuration
                    </p>
                  </div>
                </div>
                <button
                  onClick={() => setShowYamlPreview(false)}
                  className="px-4 py-2 bg-white/20 hover:bg-white/30 backdrop-blur-sm text-white rounded-lg transition-all font-semibold"
                >
                  Close
                </button>
              </div>
            </div>
            <div className="flex-1 overflow-hidden p-4">
              <YamlPreview project={project} yamlType={activeYamlView} />
            </div>
          </div>
        </div>
      )}

      {/* Re-run Confirmation Dialog */}
      {showRerunConfirmation && (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full overflow-hidden border border-gray-200">
            <div className="bg-gradient-to-r from-blue-600 to-indigo-600 text-white p-6">
              <div className="flex items-center gap-3">
                <div className="bg-white/20 p-2 rounded-lg">
                  <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                </div>
                <div>
                  <h2 className="text-xl font-bold">Re-run Tests?</h2>
                  <p className="text-sm text-white/80 mt-1">
                    Test with updated prompts
                  </p>
                </div>
              </div>
            </div>
            <div className="p-6">
              <p className="text-gray-700 mb-6">
                You've successfully applied the AI-suggested prompt changes. Would you like to re-run the evaluation with the updated prompts to see if the improvements are effective?
              </p>
              <div className="flex gap-3 justify-end">
                <button
                  onClick={handleCancelRerun}
                  className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors font-medium text-sm"
                >
                  Not Now
                </button>
                <button
                  onClick={handleConfirmRerun}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium text-sm flex items-center gap-2"
                >
                  <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                  Run Tests Now
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Logs modal - Redesigned */}
      {showLogs && (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-2xl shadow-2xl max-w-6xl w-full max-h-[85vh] flex flex-col overflow-hidden border border-gray-200">
            {/* Header */}
            <div className="bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 text-white p-6">
              <div className="flex items-center justify-between mb-4">
                <div className="flex items-center gap-3">
                  <div className="bg-white/20 p-2 rounded-lg">
                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                  </div>
                  <div>
                    <h2 className="text-2xl font-bold">Evaluation Logs</h2>
                    <p className="text-sm text-white/80 mt-1">
                      {isRunning ? 'Tests are running...' : 'Evaluation complete'}
                    </p>
                  </div>
                </div>
                <div className="flex gap-2">
                  {isRunning && (
                    <button
                      onClick={handleAbortEval}
                      className="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg flex items-center gap-2 shadow-lg transition-all hover:scale-105 font-semibold"
                    >
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                      Abort Evaluation
                    </button>
                  )}
                  {!isRunning && (
                    <button
                      onClick={() => setShowLogs(false)}
                      className="px-4 py-2 bg-white/20 hover:bg-white/30 backdrop-blur-sm text-white rounded-lg transition-all font-semibold"
                    >
                      Close
                    </button>
                  )}
                </div>
              </div>

              {/* Progress Section */}
              {isRunning && (
                <div className="bg-white/10 backdrop-blur-md rounded-xl p-4 border border-white/20">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-4">
                      <span className="text-lg font-bold">
                        Running evaluation
                      </span>
                    </div>
                    <div className="flex items-center gap-2">
                      <svg className="animate-spin h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                      </svg>
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Logs Content */}
            <div className="flex-1 overflow-auto p-6 bg-gradient-to-br from-gray-900 via-slate-900 to-gray-900">
              {logs.length === 0 && (
                <div className="flex flex-col items-center justify-center h-full text-gray-400">
                  <svg className="w-16 h-16 mb-4 opacity-50 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                  <div className="text-lg font-semibold">Initializing evaluation...</div>
                  <div className="text-sm mt-2">Logs will appear here</div>
                </div>
              )}
              <div className="font-mono text-sm space-y-1">
                {logs.map((log, index) => {
                  // Color code different log types
                  let logClass = 'text-green-400';
                  if (log.includes('âœ“') || log.toLowerCase().includes('pass') || log.toLowerCase().includes('success')) {
                    logClass = 'text-green-400 font-semibold';
                  } else if (log.includes('âœ—') || log.toLowerCase().includes('fail') || log.toLowerCase().includes('error')) {
                    logClass = 'text-red-400 font-semibold';
                  } else if (log.toLowerCase().includes('warn')) {
                    logClass = 'text-yellow-400';
                  } else if (log.toLowerCase().includes('info')) {
                    logClass = 'text-blue-400';
                  } else if (log.match(/\d+\/\d+/)) {
                    logClass = 'text-purple-400 font-semibold';
                  }

                  return (
                    <div
                      key={index}
                      className={`whitespace-pre-wrap ${logClass} leading-relaxed hover:bg-white/5 px-2 py-1 rounded transition-colors`}
                    >
                      {log}
                    </div>
                  );
                })}
                {isRunning && (
                  <div className="flex items-center gap-2 mt-4 text-blue-400 text-base font-semibold">
                    <svg className="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span className="animate-pulse">Processing evaluation...</span>
                  </div>
                )}
              </div>
            </div>

            {/* Footer */}
            <div className="bg-gray-100 border-t border-gray-200 px-6 py-3 flex items-center justify-between text-sm">
              <div className="text-gray-600 flex items-center gap-2">
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span>{logs.length} log entries</span>
              </div>
              <div className="text-gray-600">
                {isRunning ? (
                  <span className="flex items-center gap-2 text-blue-600 font-semibold">
                    <span className="relative flex h-3 w-3">
                      <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-blue-400 opacity-75"></span>
                      <span className="relative inline-flex rounded-full h-3 w-3 bg-blue-500"></span>
                    </span>
                    Evaluation in progress
                  </span>
                ) : (
                  <span className="text-green-600 font-semibold flex items-center gap-2">
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                    </svg>
                    Evaluation finished
                  </span>
                )}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Settings Modal */}
      {showSettingsModal && (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-2xl shadow-2xl w-[90vw] max-w-4xl max-h-[90vh] flex flex-col overflow-hidden border border-gray-200">
            <div className="bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 text-white p-4">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <div className="bg-white/20 p-2 rounded-lg">
                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                  </div>
                  <div>
                    <h2 className="text-xl font-bold">Settings</h2>
                    <p className="text-xs text-white/80 mt-0.5">
                      Configure application settings
                    </p>
                  </div>
                </div>
                <button
                  onClick={handleCloseSettingsModal}
                  className="px-4 py-2 bg-white/20 hover:bg-white/30 backdrop-blur-sm text-white rounded-lg transition-all font-semibold"
                >
                  Close
                </button>
              </div>
            </div>
            <div className="flex-1 overflow-auto p-6">
              <OptionsForm
                options={options}
                onChange={setOptions}
                onBigQuerySyncChange={(syncing) => {
                  console.log('App.tsx (modal): onBigQuerySyncChange called with:', syncing);
                  setIsBigQuerySyncing(syncing);
                }}
              />
            </div>
          </div>
        </div>
      )}

      {/* BigQuery Sync Overlay - Blocks UI while syncing */}
      {isBigQuerySyncing && (
        <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-lg shadow-2xl p-8 max-w-lg w-full">
            <div className="flex flex-col items-center gap-6">
              <svg className="animate-spin h-12 w-12 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>

              <div className="text-center">
                <h3 className="text-xl font-semibold text-gray-900 mb-2">Syncing BigQuery Data</h3>
                <p className="text-sm text-gray-600 mb-4">Please wait while we sync your evaluation history from BigQuery to local storage.</p>
              </div>

              {/* Quality Engineering Jokes */}
              <div className="w-full bg-blue-50 border border-blue-200 rounded-lg p-4">
                <div className="flex items-start gap-3">
                  <svg className="w-5 h-5 text-blue-600 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
                  </svg>
                  <div className="flex-1">
                    <p className="text-sm font-medium text-blue-900 mb-1">QE Wisdom</p>
                    <p className="text-sm text-blue-800 italic">
                      {(() => {
                        const jokes = [
                          "A QA engineer walks into a bar. Orders a beer. Orders 0 beers. Orders 99999999999 beers. Orders -1 beers. Orders a lizard. Orders NULL. The bar goes live. A customer orders a beer and the bar catches fire.",
                          "Why do QA engineers make terrible comedians? They always find bugs in the punchline before anyone else laughs.",
                          "How many QA engineers does it take to change a lightbulb? They noticed it was out, filed a bug report, verified it in three environments, but the PM said it's 'working as intended' because the room has windows.",
                          "A QA engineer's favorite magic trick? Making critical bugs appear right before deployment.",
                          "Why don't QA engineers ever get lost? Because they've already tested every possible wrong turn in the dev environment.",
                          "QA Engineer's definition of optimism: Writing test cases for features that might actually ship on time.",
                          "What's the difference between a QA engineer and a detective? The detective is surprised when they find the culprit.",
                          "Why do QA engineers love camping? They're experts at finding edge cases in the wilderness.",
                          "A developer's code works on their machine. A QA engineer's code doesn't work on any machine. That's the difference between confidence and thoroughness.",
                          "QA engineers don't see the glass as half full or half empty. They see it as twice the required capacity with potential overflow vulnerabilities."
                        ];
                        return jokes[Math.floor(Math.random() * jokes.length)];
                      })()}
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Documentation Modal */}
      {showDocumentation && (
        <Documentation onClose={() => setShowDocumentation(false)} />
      )}
    </div>
  );
}

export default App;
